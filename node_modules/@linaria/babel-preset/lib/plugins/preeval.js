"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = preeval;
var _logger = require("@linaria/logger");
var _utils = require("@linaria/utils");
var _processTemplateExpression = require("../utils/processTemplateExpression");
/**
 * This file is a babel preset used to transform files inside evaluators.
 * It works the same as main `babel/extract` preset, but do not evaluate lazy dependencies.
 */

const onFinishCallbacks = new WeakMap();
function preeval(babel, {
  eventEmitter = _utils.EventEmitter.dummy,
  ...options
}) {
  const {
    types: t
  } = babel;
  return {
    name: '@linaria/babel/preeval',
    pre(file) {
      const filename = file.opts.filename;
      const log = (0, _logger.createCustomDebug)('preeval', (0, _utils.getFileIdx)(filename));
      log('start', 'Looking for template literalsâ€¦');
      const rootScope = file.scope;
      this.processors = [];
      const onProcessTemplateFinished = eventEmitter.pair({
        method: 'preeval:processTemplate'
      });
      file.path.traverse({
        Identifier: p => {
          (0, _processTemplateExpression.processTemplateExpression)(p, file.opts, options, processor => {
            processor.dependencies.forEach(dependency => {
              if (dependency.ex.type === 'Identifier') {
                (0, _utils.addIdentifierToLinariaPreval)(rootScope, dependency.ex.name);
              }
            });
            processor.doEvaltimeReplacement();
            this.processors.push(processor);
          });
        }
      });
      onProcessTemplateFinished();
      if ((0, _utils.isFeatureEnabled)(options.features, 'dangerousCodeRemover', filename)) {
        log('start', 'Strip all JSX and browser related stuff');
        const onCodeRemovingFinished = eventEmitter.pair({
          method: 'preeval:removeDangerousCode'
        });
        (0, _utils.removeDangerousCode)(file.path);
        onCodeRemovingFinished();
      }
      onFinishCallbacks.set(this, eventEmitter.pair({
        method: 'preeval:rest-transformations'
      }));
    },
    visitor: {},
    post(file) {
      var _onFinishCallbacks$ge;
      (_onFinishCallbacks$ge = onFinishCallbacks.get(this)) === null || _onFinishCallbacks$ge === void 0 ? void 0 : _onFinishCallbacks$ge();
      const log = (0, _logger.createCustomDebug)('preeval', (0, _utils.getFileIdx)(file.opts.filename));
      if (this.processors.length === 0) {
        log('end', "We didn't find any Linaria template literals");

        // We didn't find any Linaria template literals.
        return;
      }
      this.file.metadata.linaria = {
        processors: this.processors,
        replacements: [],
        rules: {},
        dependencies: []
      };
      const linariaPreval = file.path.getData('__linariaPreval');
      if (!linariaPreval) {
        // Event if there is no dependencies, we still need to add __linariaPreval
        const linariaExport = t.expressionStatement(t.assignmentExpression('=', t.memberExpression(t.identifier('exports'), t.identifier('__linariaPreval')), t.objectExpression([])));
        file.path.pushContainer('body', linariaExport);
      }
      log('end', '__linariaPreval has been added');
    }
  };
}
//# sourceMappingURL=preeval.js.map