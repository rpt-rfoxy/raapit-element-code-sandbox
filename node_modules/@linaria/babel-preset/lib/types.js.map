{"version":3,"file":"types.js","names":["_utils","require"],"sources":["../src/types.ts"],"sourcesContent":["import type { BabelFile, BabelFileMetadata, PluginPass } from '@babel/core';\nimport type { NodePath } from '@babel/traverse';\nimport type { File } from '@babel/types';\nimport type { RawSourceMap } from 'source-map';\n\nimport type { BaseProcessor } from '@linaria/tags';\nimport type { LinariaMetadata, Replacement, Rules } from '@linaria/utils';\n\nimport type { PluginOptions } from './transform-stages/helpers/loadLinariaOptions';\n\nexport type { Value, ValueCache } from '@linaria/tags';\n\nexport type {\n  ExpressionValue,\n  FunctionValue,\n  JSONArray,\n  JSONObject,\n  JSONValue,\n  LazyValue,\n  Serializable,\n} from '@linaria/utils';\n\nexport { ValueType } from '@linaria/utils';\n\nexport type Dependencies = string[];\n\nexport interface IPluginState extends PluginPass {\n  processors: BaseProcessor[];\n  dependencies: Dependencies;\n  file: BabelFile & {\n    metadata: {\n      linaria?: LinariaMetadata;\n    };\n  };\n}\n\nexport interface ITransformFileResult {\n  metadata?: BabelFileMetadata;\n  code: string;\n}\n\nexport type Stage = 'preeval' | 'collect';\n\nexport type Result = {\n  code: string;\n  sourceMap?: RawSourceMap | null;\n  cssText?: string;\n  cssSourceMapText?: string;\n  dependencies?: string[];\n  rules?: Rules;\n  replacements?: Replacement[];\n};\n\nexport type Options = {\n  filename: string;\n  inputSourceMap?: RawSourceMap;\n  outputFilename?: string;\n  pluginOptions?: Partial<PluginOptions>;\n  preprocessor?: Preprocessor;\n  root?: string;\n};\n\nexport type PreprocessorFn = (selector: string, cssText: string) => string;\nexport type Preprocessor = 'none' | 'stylis' | PreprocessorFn | void;\n\nexport type MissedBabelCoreTypes = {\n  File: new (\n    options: { filename: string },\n    file: { code: string; ast: File }\n  ) => { path: NodePath<File> };\n};\n"],"mappings":";;;;;;;;;;;AAsBA,IAAAA,MAAA,GAAAC,OAAA"}