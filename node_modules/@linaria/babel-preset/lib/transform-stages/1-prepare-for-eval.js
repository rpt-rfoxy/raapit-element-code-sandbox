"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEntrypoint = createEntrypoint;
exports.default = prepareForEval;
exports.prepareCode = prepareCode;
exports.prepareForEvalSync = prepareForEvalSync;
var _fs = require("fs");
var _path = require("path");
var _logger = require("@linaria/logger");
var _utils = require("@linaria/utils");
var _withLinariaMetadata = _interopRequireDefault(require("../utils/withLinariaMetadata"));
var _ModuleQueue = require("./helpers/ModuleQueue");
var _parseFile = require("./helpers/parseFile");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
/* eslint-disable no-restricted-syntax,no-continue,no-await-in-loop */

const getKey = plugin => {
  if (typeof plugin === 'string') {
    return plugin;
  }
  if (Array.isArray(plugin)) {
    return getKey(plugin[0]);
  }
  if (typeof plugin === 'object' && plugin !== null && 'key' in plugin) {
    var _key;
    return (_key = plugin.key) !== null && _key !== void 0 ? _key : null;
  }
  return null;
};
const hasKeyInList = (plugin, list) => {
  const pluginKey = getKey(plugin);
  return pluginKey ? list.some(i => pluginKey.includes(i)) : false;
};
function runPreevalStage(babel, item, originalAst, pluginOptions, eventEmitter) {
  var _babelOptions$plugins, _babelOptions$plugins2, _babelOptions$plugins3, _result$ast;
  const babelOptions = item.parseConfig;
  const preShakePlugins = (_babelOptions$plugins = (_babelOptions$plugins2 = babelOptions.plugins) === null || _babelOptions$plugins2 === void 0 ? void 0 : _babelOptions$plugins2.filter(i => hasKeyInList(i, pluginOptions.highPriorityPlugins))) !== null && _babelOptions$plugins !== void 0 ? _babelOptions$plugins : [];
  const plugins = [...preShakePlugins, [require.resolve('../plugins/preeval'), {
    ...pluginOptions,
    eventEmitter
  }], ...((_babelOptions$plugins3 = babelOptions.plugins) !== null && _babelOptions$plugins3 !== void 0 ? _babelOptions$plugins3 : []).filter(i => !hasKeyInList(i, pluginOptions.highPriorityPlugins))];
  const transformConfig = (0, _utils.buildOptions)({
    ...babelOptions,
    envName: 'linaria',
    plugins
  });
  const result = babel.transformFromAstSync(originalAst, item.code, transformConfig);
  if (!result || !((_result$ast = result.ast) !== null && _result$ast !== void 0 && _result$ast.program)) {
    throw new Error('Babel transform failed');
  }
  return result;
}
function prepareCode(babel, item, originalAst, pluginOptions, eventEmitter) {
  const {
    evaluator,
    name: filename,
    parseConfig,
    only
  } = item;
  const log = (0, _logger.createCustomDebug)('transform', (0, _utils.getFileIdx)(filename));
  const onPreevalFinished = eventEmitter.pair({
    method: 'preeval'
  });
  const preevalStageResult = runPreevalStage(babel, item, originalAst, pluginOptions, eventEmitter);
  onPreevalFinished();
  if (only.length === 1 && only[0] === '__linariaPreval' && !(0, _withLinariaMetadata.default)(preevalStageResult.metadata)) {
    log('stage-1:evaluator:end', 'no metadata');
    return [preevalStageResult.code, null, preevalStageResult.metadata];
  }
  log('stage-1:preeval', 'metadata %O', preevalStageResult.metadata);
  log('stage-1:evaluator:start', 'using %s', evaluator.name);
  const evaluatorConfig = {
    onlyExports: only,
    highPriorityPlugins: pluginOptions.highPriorityPlugins,
    features: pluginOptions.features
  };
  const onEvaluatorFinished = eventEmitter.pair({
    method: 'evaluator'
  });
  const [, code, imports] = evaluator(parseConfig, preevalStageResult.ast, preevalStageResult.code, evaluatorConfig, babel);
  onEvaluatorFinished();
  log('stage-1:evaluator:end', '');
  return [code, imports, preevalStageResult.metadata];
}
function processQueueItem(babel, item, cache, pluginOptions, eventEmitter) {
  var _cache$originalASTCac;
  if (!item) {
    return undefined;
  }
  const {
    parseConfig,
    name,
    only,
    code
  } = item;
  const onParseFinished = eventEmitter.pair({
    method: 'parseFile'
  });
  const ast = (_cache$originalASTCac = cache.originalASTCache.get(name)) !== null && _cache$originalASTCac !== void 0 ? _cache$originalASTCac : (0, _parseFile.parseFile)(babel, name, code, parseConfig);
  onParseFinished();
  const log = (0, _logger.createCustomDebug)('transform', (0, _utils.getFileIdx)(name));
  cache.originalASTCache.set(name, ast);
  const onlyAsStr = only.join(', ');
  log('stage-1', `>> (${onlyAsStr})`);
  const [preparedCode, imports, metadata] = prepareCode(babel, item, ast, pluginOptions, eventEmitter);
  if (code === preparedCode) {
    log('stage-1', `<< (${onlyAsStr})\n === no changes ===`);
  } else {
    log('stage-1', `<< (${onlyAsStr})\n${preparedCode}`);
  }
  if (preparedCode === '') return undefined;
  return {
    imports,
    name,
    result: {
      code: preparedCode,
      metadata
    }
  };
}
const isEqual = ([...a], [...b]) => {
  if (a.includes('*')) return true;
  if (a.length !== b.length) return false;
  a.sort();
  b.sort();
  return a.every((item, index) => item === b[index]);
};
function createEntrypoint(babel, name, only, maybeCode, pluginOptions, options, eventEmitter) {
  const finishEvent = eventEmitter.pair({
    method: 'createEntrypoint'
  });
  const log = (0, _logger.createCustomDebug)('transform', (0, _utils.getFileIdx)(name));
  const extension = (0, _path.extname)(name);
  if (!pluginOptions.extensions.includes(extension)) {
    log('createEntrypoint', `${name} is ignored. If you want it to be processed, you should add '${extension}' to the "extensions" option.`);
    finishEvent();
    return 'ignored';
  }
  const code = maybeCode !== null && maybeCode !== void 0 ? maybeCode : (0, _fs.readFileSync)(name, 'utf-8');
  const {
    action,
    babelOptions
  } = (0, _parseFile.getMatchedRule)(pluginOptions.rules, name, code);
  if (action === 'ignore') {
    log('createEntrypoint', `${name} is ignored by rule`);
    finishEvent();
    return 'ignored';
  }
  const evaluator = typeof action === 'function' ? action : require(require.resolve(action, {
    paths: [(0, _path.dirname)(name)]
  })).default;
  const parseConfig = (0, _utils.buildOptions)(pluginOptions === null || pluginOptions === void 0 ? void 0 : pluginOptions.babelOptions, babelOptions, {
    ast: true,
    filename: name,
    inputSourceMap: options.inputSourceMap,
    root: options.root,
    sourceFileName: name,
    sourceMaps: true
  });
  const fullParserOptions = (0, _utils.loadBabelOptions)(babel, name, parseConfig);
  log('createEntrypoint', `${name} (${only.join(', ')})\n${code}`);
  finishEvent();
  return {
    code,
    evaluator,
    name,
    only,
    parseConfig: fullParserOptions
  };
}
function processImports(babel, log, cache, queue, pluginOptions, options, parent, resolvedImports, eventEmitter) {
  for (const {
    importedFile,
    importsOnly,
    resolved
  } of resolvedImports) {
    if (resolved === null) {
      log('stage-1:resolve', `✅ %s in %s is ignored`, importedFile, parent.entrypoint.name);
      continue;
    }
    const resolveCacheKey = `${parent.entrypoint.name} -> ${importedFile}`;
    const resolveCached = cache.resolveCache.get(resolveCacheKey);
    const importsOnlySet = new Set(importsOnly);
    if (resolveCached) {
      const [, cachedOnly] = resolveCached.split('\0');
      cachedOnly === null || cachedOnly === void 0 ? void 0 : cachedOnly.split(',').forEach(token => {
        importsOnlySet.add(token);
      });
    }
    cache.resolveCache.set(resolveCacheKey, `${resolved}\0${[...importsOnlySet].join(',')}`);
    const next = createEntrypoint(babel, resolved, [...importsOnlySet], undefined, pluginOptions, options, eventEmitter);
    if (next === 'ignored') {
      continue;
    }
    queue.enqueue([next, [parent.entrypoint.name, ...parent.stack]]);
  }
}

// FIXME: naming
function processEntrypoint(babel, log, cache, pluginOptions, options, nextItem, eventEmitter) {
  const {
    code,
    name,
    only
  } = nextItem.entrypoint;
  cache.invalidateIfChanged(name, code);
  const cached = cache.codeCache.get(name);
  // If we already have a result for this file, we should get a result for merged `only`
  const mergedOnly = cached !== null && cached !== void 0 && cached.only ? Array.from(new Set([...cached.only, ...only])) : only;
  let imports = null;
  let result;
  if (cached) {
    if (isEqual(cached.only, mergedOnly)) {
      log('stage-1', '%s is already processed', name);
      if (!nextItem.stack.includes(nextItem.entrypoint.name)) {
        imports = cached.imports;
      }
      result = cached.result;
    } else {
      log('stage-1', '%s is already processed, but with different `only` %o (the cached one %o)', name, only, cached === null || cached === void 0 ? void 0 : cached.only);

      // If we already have a result for this file, we should invalidate it
      cache.evalCache.delete(name);
    }
  }
  if (!result) {
    const processed = processQueueItem(babel, {
      ...nextItem.entrypoint,
      only: mergedOnly
    }, cache, pluginOptions, eventEmitter);
    if (!processed) {
      log('stage-1', '%s is skipped', name);
      return 'skip';
    }
    imports = processed.imports;
    result = processed.result;
  }
  return {
    imports,
    result,
    only: mergedOnly
  };
}
function prepareForEvalSync(babel, cache, resolve, partialEntrypoint, pluginOptions, options, eventEmitter = _utils.EventEmitter.dummy) {
  var _cache$codeCache$get;
  const log = (0, _logger.createCustomDebug)('transform', (0, _utils.getFileIdx)(partialEntrypoint.name));
  const entrypoint = createEntrypoint(babel, partialEntrypoint.name, partialEntrypoint.only, partialEntrypoint.code, pluginOptions, options, eventEmitter);
  if (entrypoint === 'ignored') {
    return undefined;
  }
  const queue = new _ModuleQueue.ModuleQueue(entrypoint);
  while (!queue.isEmpty()) {
    var _imports$entries;
    const item = queue.dequeue();
    if (!item) {
      continue;
    }
    const processResult = processEntrypoint(babel, log, cache, pluginOptions, options, item, eventEmitter);
    if (processResult === 'skip') {
      continue;
    }
    const {
      imports,
      result,
      only: mergedOnly
    } = processResult;
    const listOfImports = Array.from((_imports$entries = imports === null || imports === void 0 ? void 0 : imports.entries()) !== null && _imports$entries !== void 0 ? _imports$entries : []);
    if (listOfImports.length > 0) {
      const onResolveFinished = eventEmitter.pair({
        method: 'resolve'
      });
      const resolvedImports = listOfImports.map(([importedFile, importsOnly]) => {
        let resolved = null;
        try {
          resolved = resolve(importedFile, item.entrypoint.name, item.stack);
          log('stage-1:sync-resolve', `✅ ${importedFile} -> ${resolved} (only: %o)`, importsOnly);
        } catch (err) {
          log('stage-1:sync-resolve', `❌ cannot resolve ${importedFile}: %O`, err);
        }
        return {
          importedFile,
          importsOnly,
          resolved
        };
      });
      onResolveFinished();
      eventEmitter.single({
        type: 'dependency',
        file: item.entrypoint.name,
        only: item.entrypoint.only,
        imports: resolvedImports.map(({
          resolved,
          importsOnly
        }) => ({
          from: resolved,
          what: importsOnly
        }))
      });
      processImports(babel, log, cache, queue, pluginOptions, options, item, resolvedImports, eventEmitter);
    } else {
      eventEmitter.single({
        type: 'dependency',
        file: item.entrypoint.name,
        only: item.entrypoint.only,
        imports: []
      });
      log('stage-1', '%s has no imports', item.entrypoint.name);
    }
    cache.codeCache.set(item.entrypoint.name, {
      imports,
      only: mergedOnly,
      result
    });
  }
  return (_cache$codeCache$get = cache.codeCache.get(entrypoint.name)) === null || _cache$codeCache$get === void 0 ? void 0 : _cache$codeCache$get.result;
}

/**
 * Parses the specified file and recursively all its dependencies,
 * finds tags, applies eval-time replacements, removes dead code.
 */
async function prepareForEval(babel, cache, resolve, partialEntrypoint, pluginOptions, options, eventEmitter = _utils.EventEmitter.dummy) {
  var _cache$codeCache$get2;
  /*
   * This method can be run simultaneously for multiple files.
   * A shared cache is accessible for all runs, but each run has its own queue
   * to maintain the correct processing order. The cache stores the outcome
   * of tree-shaking, and if the result is already stored in the cache
   * but the "only" option has changed, the file will be re-processed using
   * the combined "only" option.
   */
  const log = (0, _logger.createCustomDebug)('transform', (0, _utils.getFileIdx)(partialEntrypoint.name));
  const entrypoint = createEntrypoint(babel, partialEntrypoint.name, partialEntrypoint.only, partialEntrypoint.code, pluginOptions, options, eventEmitter);
  if (entrypoint === 'ignored') {
    return undefined;
  }
  const queue = new _ModuleQueue.ModuleQueue(entrypoint);
  while (!queue.isEmpty()) {
    var _imports$entries2;
    const item = queue.dequeue();
    if (!item) {
      continue;
    }
    const processResult = processEntrypoint(babel, log, cache, pluginOptions, options, item, eventEmitter);
    if (processResult === 'skip') {
      continue;
    }
    const {
      imports,
      result,
      only: mergedOnly
    } = processResult;
    const listOfImports = Array.from((_imports$entries2 = imports === null || imports === void 0 ? void 0 : imports.entries()) !== null && _imports$entries2 !== void 0 ? _imports$entries2 : []);
    if (listOfImports.length > 0) {
      const onResolveFinished = eventEmitter.pair({
        method: 'resolve'
      });
      const resolvedImports = await Promise.all(listOfImports.map(async ([importedFile, importsOnly]) => {
        let resolved = null;
        try {
          resolved = await resolve(importedFile, item.entrypoint.name, item.stack);
        } catch (err) {
          log('stage-1:async-resolve', `❌ cannot resolve %s in %s: %O`, importedFile, item.entrypoint.name, err);
        }
        if (resolved !== null) {
          log('stage-1:async-resolve', `✅ %s (%o) in %s -> %s`, importedFile, importsOnly, item.entrypoint.name, resolved);
        }
        return {
          importedFile,
          importsOnly,
          resolved
        };
      }));
      onResolveFinished();
      eventEmitter.single({
        type: 'dependency',
        file: item.entrypoint.name,
        only: item.entrypoint.only,
        imports: resolvedImports.map(({
          resolved,
          importsOnly
        }) => ({
          from: resolved,
          what: importsOnly
        }))
      });
      processImports(babel, log, cache, queue, pluginOptions, options, item, resolvedImports, eventEmitter);
    } else {
      eventEmitter.single({
        type: 'dependency',
        file: item.entrypoint.name,
        only: item.entrypoint.only,
        imports: []
      });
      log('stage-1', '%s has no imports', item.entrypoint.name);
    }
    cache.codeCache.set(item.entrypoint.name, {
      imports,
      only: mergedOnly,
      result
    });
  }
  log('stage-1', 'queue is empty, %s is ready', entrypoint.name);
  return (_cache$codeCache$get2 = cache.codeCache.get(entrypoint.name)) === null || _cache$codeCache$get2 === void 0 ? void 0 : _cache$codeCache$get2.result;
}
//# sourceMappingURL=1-prepare-for-eval.js.map